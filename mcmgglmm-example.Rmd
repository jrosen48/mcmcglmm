---
title: "MCMCglmm test"
author: "Joshua Rosenberg"
date: "3/2/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE)
```

The aim of this analysis is to carry out in a single model (using MCMCglmm) what I have been running in separate models. This document presents my attempt to run three models:

1. An example from a thread with Tom Houslay/Jarred Hadfield in response to a question to R-sig-mixed-models (https://stat.ethz.ch/pipermail/r-sig-mixed-models/2017q4/026092.html)
2. My attempt to do the analysis using two separate models using lme4/ best linear unbiased predictors (BLUPs)
3. My attempt to fit a similar model as in step 2, but using MCMCglmm

** Loading packages** 

```{r}
library(MCMCglmm)
library(lme4)
library(tidyverse)
```

# 1. Example from Jarrred Hadfield

```{r, example-from-jarred-hadfield}

N<-500
# 500 individuals

V<-matrix(c(1,0.5, 0.5, 1),2,2)
# 2x2 random/residual-effect covariance matrix

Vr<-matrix(1,1,1)
# residual variance for repeat measure trait

u<-MASS::mvrnorm(N, rep(0, 2), V)
# random effect for repeat measure trait followed by
# residuals for the single measured trait.

e<-rnorm(2*N,0,sqrt(Vr))
# residuals for the repeat trait

ysingle<-1+u[,2]
# single measure traits has intercept of 1

individual<-as.factor(rep(1:N, 3))
# individuals are ordered within each trait/time combination

type<-as.factor(c(rep("s", N), rep("r",2*N)))
# designate which observations are single measures (s)
# or repeat measures (r)

yrep<--1+u[rep(1:N, 2),1]+e
# the repeat measure trait has an intercept of -1

dat1<-data.frame(y=c(ysingle,yrep), type=type,
                 individual=individual)

prior1<-list(R=list(R1=list(V=V, nu=0, covu=TRUE),
                    R2=list(V=Vr, nu=0)))

str(dat1)

# use flat priors, but use covu=TRUE to mdoel covariances
# between R1 effects and the random effects
# (G is not needed because random effect prior is
#  specified in R1)

m.test1<-MCMCglmm(y~type-1,
                  random=~us(at.level(type,"r")):individual,
                  rcov=~us(at.level(type, "s")):individual+us(at.level(type, "r")):units,
                  data=dat1,
                  prior=prior1,
                  verbose=FALSE)

summary(m.test1)
```

# 2. Josh example with BLUPs

```{r, josh-example-blups}
# load packages that are loaded above
# library(tidyverse)
# library(lme4)

d <- read_csv("mcmcglmm-data.csv")

m1 <- lmer(rm_engagement ~ 1 + (1 | participant_ID) + (1 | program_ID), data = d)
m1

d_BLUP <- ranef(m1) %>% 
    pluck(1) %>% 
    rownames_to_column("participant_ID") %>% 
    mutate(participant_ID = as.integer(participant_ID)) %>% 
    rename(rm_engagement_BLUP = `(Intercept)`) 

d_ind_level <- distinct(d, participant_ID, post_interest, program_ID)
d_for_m2 <- left_join(d_ind_level, d_BLUP, by = "participant_ID")
d_for_m2 <- filter(d_for_m2, !is.na(post_interest))
    
m2 <- lmer(post_interest ~ 1 + rm_engagement_BLUP + (1 | program_ID), data = d_for_m2)
m2

```

# 3. Josh example with MCMCglmm

```{r, josh-example-mcmc}
# load packages that are loaded above
# library(tidyverse)
# library(MCMCglmm)

# load data that is loaded above
# d <- read_csv("mcmcglmm-data.csv")

V<-matrix(c(1,0.5, 0.5, 1),2,2)
# 2x2 random/residual-effect covariance matrix

Vr<-matrix(1,1,1)
# residual variance for repeat measure trait

prior1<-list(R=list(R1=list(V=V, nu=0, covu=TRUE),
                    R2=list(V=Vr, nu=0)))

# Preparing/structuring data 
ind <- distinct(d, participant_ID, post_interest)
rep <- select(d, participant_ID, rm_engagement)
type <- c(rep("s", nrow(ind)), rep("r", nrow(rep)))
dd <- data.frame(y = c(ind$post_interest, rep$rm_engagement),
                 type = as.factor(type),
                 individual = as.factor(c(as.character(ind$participant_ID), as.character(rep$participant_ID))))

m.test2 <- MCMCglmm(y ~ type-1,
                    random=~us(at.level(type,"r")):individual,
                    rcov=~us(at.level(type, "s")):individual + us(at.level(type, "r")):units,
                    data=dd,
                    prior=prior1,
                    verbose=FALSE)

summary(m.test2)
```
